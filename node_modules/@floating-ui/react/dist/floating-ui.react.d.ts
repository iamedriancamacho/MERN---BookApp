import { AlignedPlacement } from '@floating-ui/react-dom';
import { Alignment } from '@floating-ui/react-dom';
import { arrow } from '@floating-ui/react-dom';
import { ArrowOptions } from '@floating-ui/react-dom';
import { autoPlacement } from '@floating-ui/react-dom';
import { AutoPlacementOptions } from '@floating-ui/react-dom';
import { autoUpdate } from '@floating-ui/react-dom';
import { AutoUpdateOptions } from '@floating-ui/react-dom';
import { Axis } from '@floating-ui/react-dom';
import { Boundary } from '@floating-ui/react-dom';
import { ClientRectObject } from '@floating-ui/react-dom';
import { computePosition } from '@floating-ui/react-dom';
import { ComputePositionConfig } from '@floating-ui/react-dom';
import { ComputePositionReturn } from '@floating-ui/react-dom';
import { Coords } from '@floating-ui/react-dom';
import { detectOverflow } from '@floating-ui/react-dom';
import { DetectOverflowOptions } from '@floating-ui/react-dom';
import { Dimensions } from '@floating-ui/react-dom';
import { ElementContext } from '@floating-ui/react-dom';
import { ElementRects } from '@floating-ui/react-dom';
import { Elements } from '@floating-ui/react-dom';
import { flip } from '@floating-ui/react-dom';
import { FlipOptions } from '@floating-ui/react-dom';
import { FloatingElement } from '@floating-ui/react-dom';
import { getOverflowAncestors } from '@floating-ui/react-dom';
import { hide } from '@floating-ui/react-dom';
import { HideOptions } from '@floating-ui/react-dom';
import { inline } from '@floating-ui/react-dom';
import { InlineOptions } from '@floating-ui/react-dom';
import { Length } from '@floating-ui/react-dom';
import { limitShift } from '@floating-ui/react-dom';
import { Middleware } from '@floating-ui/react-dom';
import { MiddlewareArguments } from '@floating-ui/react-dom';
import { MiddlewareData } from '@floating-ui/react-dom';
import { MiddlewareReturn } from '@floating-ui/react-dom';
import { MiddlewareState } from '@floating-ui/react-dom';
import { NodeScroll } from '@floating-ui/react-dom';
import { offset } from '@floating-ui/react-dom';
import { OffsetOptions } from '@floating-ui/react-dom';
import { Padding } from '@floating-ui/react-dom';
import { Placement } from '@floating-ui/react-dom';
import { Platform } from '@floating-ui/react-dom';
import { platform } from '@floating-ui/react-dom';
import * as React_2 from 'react';
import { Rect } from '@floating-ui/react-dom';
import { ReferenceElement } from '@floating-ui/react-dom';
import { RootBoundary } from '@floating-ui/react-dom';
import { shift } from '@floating-ui/react-dom';
import { ShiftOptions } from '@floating-ui/react-dom';
import { Side } from '@floating-ui/react-dom';
import { SideObject } from '@floating-ui/react-dom';
import { size } from '@floating-ui/react-dom';
import { SizeOptions } from '@floating-ui/react-dom';
import { Strategy } from '@floating-ui/react-dom';
import type { UseFloatingOptions as UseFloatingOptions_2 } from '@floating-ui/react-dom';
import type { UseFloatingReturn as UseFloatingReturn_2 } from '@floating-ui/react-dom';
import { VirtualElement } from '@floating-ui/react-dom';

declare const ACTIVE_KEY = "active";

export { AlignedPlacement }

export { Alignment }

declare type AriaRole = 'tooltip' | 'dialog' | 'alertdialog' | 'menu' | 'listbox' | 'grid' | 'tree';

export { arrow }

export { ArrowOptions }

export { autoPlacement }

export { AutoPlacementOptions }

export { autoUpdate }

export { AutoUpdateOptions }

export { Axis }

export { Boundary }

export { ClientRectObject }

declare type ComponentRole = 'select' | 'label' | 'combobox';

export declare const Composite: React_2.ForwardRefExoticComponent<Omit<React_2.HTMLProps<HTMLElement> & CompositeProps, "ref"> & React_2.RefAttributes<HTMLElement>>;

export declare const CompositeItem: React_2.ForwardRefExoticComponent<Omit<React_2.HTMLProps<HTMLElement> & {
    render?: RenderProp | undefined;
}, "ref"> & React_2.RefAttributes<HTMLElement>>;

declare interface CompositeProps {
    render?: RenderProp;
    orientation?: 'horizontal' | 'vertical' | 'both';
    loop?: boolean;
    cols?: number;
    disabledIndices?: number[];
    activeIndex?: number;
    onNavigate?(index: number): void;
    /**
     * Only for `cols > 1`, specify sizes for grid items.
     * `{ width: 2, height: 2 }` means an item is 2 columns wide and 2 rows tall.
     */
    itemSizes?: Dimensions[];
    /**
     * Only relevant for `cols > 1` and items with different sizes, specify if
     * the grid is dense (as defined in the CSS spec for grid-auto-flow).
     */
    dense?: boolean;
}

export { computePosition }

export { ComputePositionConfig }

export { ComputePositionReturn }

export declare interface ContextData {
    openEvent?: Event;
    /** @deprecated use `onTypingChange` prop in `useTypeahead` */
    typing?: boolean;
    [key: string]: any;
}

export { Coords }

declare type CSSStylesProperty = React_2.CSSProperties | ((params: {
    side: Side;
    placement: Placement;
}) => React_2.CSSProperties);

declare type Delay = number | Partial<{
    open: number;
    close: number;
}>;

export { detectOverflow }

export { DetectOverflowOptions }

export { Dimensions }

export { ElementContext }

export declare interface ElementProps {
    reference?: React_2.HTMLProps<Element>;
    floating?: React_2.HTMLProps<HTMLElement>;
    item?: React_2.HTMLProps<HTMLElement> | ((props: ExtendedUserProps) => React_2.HTMLProps<HTMLElement>);
}

export { ElementRects }

export { Elements }

export declare interface ExtendedElements<RT> {
    reference: ReferenceType | null;
    floating: HTMLElement | null;
    domReference: NarrowedElement<RT> | null;
}

export declare interface ExtendedRefs<RT> {
    reference: React_2.MutableRefObject<ReferenceType | null>;
    floating: React_2.MutableRefObject<HTMLElement | null>;
    domReference: React_2.MutableRefObject<NarrowedElement<RT> | null>;
    setReference(node: RT | null): void;
    setFloating(node: HTMLElement | null): void;
    setPositionReference(node: ReferenceType | null): void;
}

declare type ExtendedUserProps = {
    [ACTIVE_KEY]?: boolean;
    [SELECTED_KEY]?: boolean;
};

export { flip }

export { FlipOptions }

/**
 * Renders a pointing arrow triangle.
 * @see https://floating-ui.com/docs/FloatingArrow
 */
export declare const FloatingArrow: React_2.ForwardRefExoticComponent<FloatingArrowProps & React_2.RefAttributes<SVGSVGElement>>;

export declare interface FloatingArrowProps extends React_2.SVGAttributes<SVGSVGElement> {
    /**
     * The floating context.
     */
    context: Omit<FloatingContext, 'refs'> & {
        refs: any;
    };
    /**
     * Width of the arrow.
     * @default 14
     */
    width?: number;
    /**
     * Height of the arrow.
     * @default 7
     */
    height?: number;
    /**
     * The corner radius (rounding) of the arrow tip.
     * @default 0 (sharp)
     */
    tipRadius?: number;
    /**
     * Forces a static offset over dynamic positioning under a certain condition.
     */
    staticOffset?: string | number | null;
    /**
     * Custom path string.
     */
    d?: string;
    /**
     * Stroke (border) color of the arrow.
     */
    stroke?: string;
    /**
     * Stroke (border) width of the arrow.
     */
    strokeWidth?: number;
}

export declare type FloatingContext<RT extends ReferenceType = ReferenceType> = Omit<UseFloatingReturn_2<RT>, 'refs' | 'elements'> & {
    open: boolean;
    onOpenChange(open: boolean, event?: Event, reason?: OpenChangeReason): void;
    events: FloatingEvents;
    dataRef: React_2.MutableRefObject<ContextData>;
    nodeId: string | undefined;
    floatingId: string;
    refs: ExtendedRefs<RT>;
    elements: ExtendedElements<RT>;
};

/**
 * Provides context for a group of floating elements that should share a
 * `delay`.
 * @see https://floating-ui.com/docs/FloatingDelayGroup
 */
export declare const FloatingDelayGroup: ({ children, delay, timeoutMs, }: FloatingDelayGroupProps) => JSX.Element;

declare interface FloatingDelayGroupProps {
    children?: React_2.ReactNode;
    delay: Delay;
    timeoutMs?: number;
}

export { FloatingElement }

export declare interface FloatingEvents {
    emit<T extends string>(event: T, data?: any): void;
    on(event: string, handler: (data: any) => void): void;
    off(event: string, handler: (data: any) => void): void;
}

/**
 * Provides focus management for the floating element.
 * @see https://floating-ui.com/docs/FloatingFocusManager
 */
export declare function FloatingFocusManager<RT extends ReferenceType = ReferenceType>(props: FloatingFocusManagerProps<RT>): JSX.Element;

export declare interface FloatingFocusManagerProps<RT extends ReferenceType = ReferenceType> {
    context: FloatingContext<RT>;
    children: JSX.Element;
    disabled?: boolean;
    order?: Array<'reference' | 'floating' | 'content'>;
    initialFocus?: number | React_2.MutableRefObject<HTMLElement | null>;
    guards?: boolean;
    returnFocus?: boolean;
    modal?: boolean;
    visuallyHiddenDismiss?: boolean | string;
    closeOnFocusOut?: boolean;
}

/**
 * Provides context for a list of items within the floating element.
 * @see https://floating-ui.com/docs/FloatingList
 */
export declare function FloatingList({ children, elementsRef, labelsRef, }: FloatingListProps): JSX.Element;

declare interface FloatingListProps {
    children: React_2.ReactNode;
    elementsRef: React_2.MutableRefObject<Array<HTMLElement | null>>;
    labelsRef?: React_2.MutableRefObject<Array<string | null>>;
}

/**
 * Provides parent node context for nested floating elements.
 * @see https://floating-ui.com/docs/FloatingTree
 */
export declare function FloatingNode({ children, id, }: {
    children?: React_2.ReactNode;
    id: string;
}): JSX.Element;

export declare interface FloatingNodeType<RT extends ReferenceType = ReferenceType> {
    id: string;
    parentId: string | null;
    context?: FloatingContext<RT>;
}

/**
 * Provides base styling for a fixed overlay element to dim content or block
 * pointer events behind a floating element.
 * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.
 * @see https://floating-ui.com/docs/FloatingOverlay
 */
export declare const FloatingOverlay: React_2.ForwardRefExoticComponent<Omit<React_2.HTMLProps<HTMLDivElement> & {
    lockScroll?: boolean | undefined;
}, "ref"> & React_2.RefAttributes<HTMLDivElement>>;

/**
 * Portals the floating element into a given container element — by default,
 * outside of the app root and into the body.
 * @see https://floating-ui.com/docs/FloatingPortal
 */
export declare function FloatingPortal({ children, id, root, preserveTabOrder, }: FloatingPortalProps): JSX.Element;

declare interface FloatingPortalProps {
    children?: React_2.ReactNode;
    id?: string;
    root?: HTMLElement | null | React_2.MutableRefObject<HTMLElement | null>;
    preserveTabOrder?: boolean;
}

/**
 * Provides context for nested floating elements when they are not children of
 * each other on the DOM (i.e. portalled to a common node, rather than their
 * respective parent).
 * @see https://floating-ui.com/docs/FloatingTree
 */
export declare function FloatingTree({ children, }: {
    children?: React_2.ReactNode;
}): JSX.Element;

export declare interface FloatingTreeType<RT extends ReferenceType = ReferenceType> {
    nodesRef: React_2.MutableRefObject<Array<FloatingNodeType<RT>>>;
    events: FloatingEvents;
    addNode(node: FloatingNodeType): void;
    removeNode(node: FloatingNodeType): void;
}

export { getOverflowAncestors }

declare interface GroupContext extends GroupState {
    setCurrentId: React_2.Dispatch<React_2.SetStateAction<any>>;
    setState: React_2.Dispatch<Partial<GroupState>>;
}

declare interface GroupState {
    delay: Delay;
    initialDelay: Delay;
    currentId: any;
    timeoutMs: number;
    isInstantPhase: boolean;
}

declare interface HandleCloseFn<RT extends ReferenceType = ReferenceType> {
    (context: FloatingContext<RT> & {
        onClose: () => void;
        tree?: FloatingTreeType<RT> | null;
        leave?: boolean;
    }): (event: MouseEvent) => void;
    __options: {
        blockPointerEvents: boolean;
    };
}

export { hide }

export { HideOptions }

export { inline }

export { InlineOptions }

/**
 * Positions the floating element such that an inner element inside
 * of it is anchored to the reference element.
 * @see https://floating-ui.com/docs/inner
 */
export declare const inner: (props: InnerProps & Partial<DetectOverflowOptions>) => Middleware;

export declare interface InnerProps {
    listRef: React_2.MutableRefObject<Array<HTMLElement | null>>;
    index: number;
    onFallbackChange?: null | ((fallback: boolean) => void);
    offset?: number;
    overflowRef?: React_2.MutableRefObject<SideObject | null>;
    scrollRef?: React_2.MutableRefObject<HTMLElement | null>;
    minItemsVisible?: number;
    referenceOverflowThreshold?: number;
}

export { Length }

export { limitShift }

export { Middleware }

export { MiddlewareArguments }

export { MiddlewareData }

export { MiddlewareReturn }

export { MiddlewareState }

export declare type NarrowedElement<T> = T extends Element ? T : Element;

export { NodeScroll }

export { offset }

export { OffsetOptions }

export declare type OpenChangeReason = 'outside-press' | 'escape-key' | 'ancestor-scroll' | 'reference-press' | 'click' | 'hover' | 'focus' | 'list-navigation' | 'safe-polygon';

export { Padding }

export { Placement }

export { Platform }

export { platform }

declare type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};

export { Rect }

export { ReferenceElement }

export declare type ReferenceType = Element | VirtualElement;

declare type RenderProp = JSX.Element | ((props: React_2.HTMLAttributes<HTMLElement>) => JSX.Element);

export { RootBoundary }

/**
 * Generates a safe polygon area that the user can traverse without closing the
 * floating element once leaving the reference element.
 * @see https://floating-ui.com/docs/useHover#safePolygon
 */
export declare function safePolygon<RT extends ReferenceType = ReferenceType>(options?: Partial<SafePolygonOptions>): HandleCloseFn<RT>;

declare interface SafePolygonOptions {
    buffer: number;
    blockPointerEvents: boolean;
    requireIntent: boolean;
}

declare const SELECTED_KEY = "selected";

export { shift }

export { ShiftOptions }

export { Side }

export { SideObject }

export { size }

export { SizeOptions }

declare type Status = 'unmounted' | 'initial' | 'open' | 'close';

export { Strategy }

/**
 * Opens or closes the floating element when clicking the reference element.
 * @see https://floating-ui.com/docs/useClick
 */
export declare function useClick<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseClickProps): ElementProps;

export declare interface UseClickProps {
    enabled?: boolean;
    event?: 'click' | 'mousedown';
    toggle?: boolean;
    ignoreMouse?: boolean;
    keyboardHandlers?: boolean;
}

/**
 * Positions the floating element relative to a client point (in the viewport),
 * such as the mouse position. By default, it follows the mouse cursor.
 * @see https://floating-ui.com/docs/useClientPoint
 */
export declare function useClientPoint<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseClientPointProps): ElementProps;

export declare interface UseClientPointProps {
    enabled?: boolean;
    axis?: 'x' | 'y' | 'both';
    x?: number | null;
    y?: number | null;
}

export declare const useDelayGroup: ({ open, onOpenChange }: FloatingContext, { id }: UseGroupOptions) => void;

export declare const useDelayGroupContext: () => GroupContext;

/**
 * Closes the floating element when a dismissal is requested — by default, when
 * the user presses the `escape` key or outside of the floating element.
 * @see https://floating-ui.com/docs/useDismiss
 */
export declare function useDismiss<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseDismissProps): ElementProps;

export declare interface UseDismissProps {
    enabled?: boolean;
    escapeKey?: boolean;
    referencePress?: boolean;
    referencePressEvent?: 'pointerdown' | 'mousedown' | 'click';
    outsidePress?: boolean | ((event: MouseEvent) => boolean);
    outsidePressEvent?: 'pointerdown' | 'mousedown' | 'click';
    ancestorScroll?: boolean;
    bubbles?: boolean | {
        escapeKey?: boolean;
        outsidePress?: boolean;
    };
    capture?: boolean | {
        escapeKey?: boolean;
        outsidePress?: boolean;
    };
}

/**
 * Provides data to position a floating element and context to add interactions.
 * @see https://floating-ui.com/docs/useFloating
 */
export declare function useFloating<RT extends ReferenceType = ReferenceType>(options?: Partial<UseFloatingOptions>): UseFloatingReturn<RT>;

export declare type UseFloatingData = Prettify<UseFloatingReturn>;

/**
 * Registers a node into the floating tree, returning its id.
 */
export declare function useFloatingNodeId(customParentId?: string): string;

export declare interface UseFloatingOptions<RT extends ReferenceType = ReferenceType> extends Omit<UseFloatingOptions_2<RT>, 'elements'> {
    /**
     * Object of external elements as an alternative to the `refs` object setters.
     */
    elements?: {
        /**
         * Externally passed reference element. Store in state.
         */
        reference?: Element | null;
        /**
         * Externally passed floating element. Store in state.
         */
        floating?: HTMLElement | null;
    };
    /**
     * An event callback that is invoked when the floating element is opened or
     * closed.
     */
    onOpenChange?(open: boolean, event?: Event, reason?: OpenChangeReason): void;
    /**
     * Unique node id when using `FloatingTree`.
     */
    nodeId?: string;
}

export declare const useFloatingParentNodeId: () => string | null;

export declare function useFloatingPortalNode({ id, root, }?: {
    id?: string;
    root?: HTMLElement | null | React_2.MutableRefObject<HTMLElement | null>;
}): HTMLElement | null;

export declare type UseFloatingReturn<RT extends ReferenceType = ReferenceType> = Prettify<UseFloatingReturn_2 & {
    context: Prettify<FloatingContext<RT>>;
    refs: ExtendedRefs<RT>;
    elements: ExtendedElements<RT>;
}>;

export declare const useFloatingTree: <RT extends ReferenceType = ReferenceType>() => FloatingTreeType<RT> | null;

/**
 * Opens the floating element while the reference element has focus, like CSS
 * `:focus`.
 * @see https://floating-ui.com/docs/useFocus
 */
export declare function useFocus<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseFocusProps): ElementProps;

export declare interface UseFocusProps {
    enabled?: boolean;
    visibleOnly?: boolean;
}

declare interface UseGroupOptions {
    id: any;
}

/**
 * Opens the floating element while hovering over the reference element, like
 * CSS `:hover`.
 * @see https://floating-ui.com/docs/useHover
 */
export declare function useHover<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseHoverProps<RT>): ElementProps;

export declare interface UseHoverProps<RT extends ReferenceType = ReferenceType> {
    enabled?: boolean;
    handleClose?: HandleCloseFn<RT> | null;
    restMs?: number;
    delay?: number | Partial<{
        open: number;
        close: number;
    }>;
    mouseOnly?: boolean;
    move?: boolean;
}

/**
 * Uses React 18's built-in `useId()` when available, or falls back to a
 * slightly less performant (requiring a double render) implementation for
 * earlier React versions.
 * @see https://floating-ui.com/docs/useId
 */
export declare const useId: () => string;

/**
 * Changes the `inner` middleware's `offset` upon a `wheel` event to
 * expand the floating element's height, revealing more list items.
 * @see https://floating-ui.com/docs/inner
 */
export declare function useInnerOffset(context: FloatingContext, props: UseInnerOffsetProps): ElementProps;

export declare interface UseInnerOffsetProps {
    enabled?: boolean;
    overflowRef: React_2.MutableRefObject<SideObject | null>;
    scrollRef?: React_2.MutableRefObject<HTMLElement | null>;
    onChange: (offset: number | ((offset: number) => number)) => void;
}

/**
 * Merges an array of interaction hooks' props into prop getters, allowing
 * event handler functions to be composed together without overwriting one
 * another.
 * @see https://floating-ui.com/docs/useInteractions
 */
export declare function useInteractions(propsList?: Array<ElementProps | void>): {
    getReferenceProps: (userProps?: React_2.HTMLProps<Element>) => Record<string, unknown>;
    getFloatingProps: (userProps?: React_2.HTMLProps<HTMLElement>) => Record<string, unknown>;
    getItemProps: (userProps?: Omit<React_2.HTMLProps<HTMLElement>, 'selected' | 'active'> & ExtendedUserProps) => Record<string, unknown>;
};

export declare function useListItem({ label }?: UseListItemProps): {
    ref: (node: HTMLElement | null) => void;
    index: number;
};

declare interface UseListItemProps {
    label?: string | null;
}

/**
 * Adds arrow key-based navigation of a list of items, either using real DOM
 * focus or virtual focus.
 * @see https://floating-ui.com/docs/useListNavigation
 */
export declare function useListNavigation<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props: UseListNavigationProps): ElementProps;

export declare interface UseListNavigationProps {
    listRef: React_2.MutableRefObject<Array<HTMLElement | null>>;
    activeIndex: number | null;
    onNavigate?: (index: number | null) => void;
    enabled?: boolean;
    selectedIndex?: number | null;
    focusItemOnOpen?: boolean | 'auto';
    focusItemOnHover?: boolean;
    openOnArrowKeyDown?: boolean;
    disabledIndices?: Array<number>;
    allowEscape?: boolean;
    loop?: boolean;
    nested?: boolean;
    rtl?: boolean;
    virtual?: boolean;
    orientation?: 'vertical' | 'horizontal' | 'both';
    cols?: number;
    scrollItemIntoView?: boolean | ScrollIntoViewOptions;
    virtualItemRef?: React_2.MutableRefObject<HTMLElement | null>;
    /**
     * Only for `cols > 1`, specify sizes for grid items.
     * `{ width: 2, height: 2 }` means an item is 2 columns wide and 2 rows tall.
     */
    itemSizes?: Dimensions[];
    /**
     * Only relevant for `cols > 1` and items with different sizes, specify if
     * the grid is dense (as defined in the CSS spec for grid-auto-flow).
     */
    dense?: boolean;
}

/**
 * Merges an array of refs into a single memoized callback ref or `null`.
 * @see https://floating-ui.com/docs/useMergeRefs
 */
export declare function useMergeRefs<Instance>(refs: Array<React_2.Ref<Instance> | undefined>): React_2.RefCallback<Instance> | null;

/**
 * Adds base screen reader props to the reference and floating elements for a
 * given floating element `role`.
 * @see https://floating-ui.com/docs/useRole
 */
export declare function useRole<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseRoleProps): ElementProps;

export declare interface UseRoleProps {
    enabled?: boolean;
    role?: AriaRole | ComponentRole;
}

/**
 * Provides a status string to apply CSS transitions to a floating element,
 * correctly handling placement-aware transitions.
 * @see https://floating-ui.com/docs/useTransition#usetransitionstatus
 */
export declare function useTransitionStatus<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseTransitionStatusProps): {
    isMounted: boolean;
    status: Status;
};

export declare interface UseTransitionStatusProps {
    duration?: number | Partial<{
        open: number;
        close: number;
    }>;
}

/**
 * Provides styles to apply CSS transitions to a floating element, correctly
 * handling placement-aware transitions. Wrapper around `useTransitionStatus`.
 * @see https://floating-ui.com/docs/useTransition#usetransitionstyles
 */
export declare function useTransitionStyles<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseTransitionStylesProps): {
    isMounted: boolean;
    styles: React_2.CSSProperties;
};

export declare interface UseTransitionStylesProps extends UseTransitionStatusProps {
    initial?: CSSStylesProperty;
    open?: CSSStylesProperty;
    close?: CSSStylesProperty;
    common?: CSSStylesProperty;
}

/**
 * Provides a matching callback that can be used to focus an item as the user
 * types, often used in tandem with `useListNavigation()`.
 * @see https://floating-ui.com/docs/useTypeahead
 */
export declare function useTypeahead<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props: UseTypeaheadProps): ElementProps;

export declare interface UseTypeaheadProps {
    listRef: React_2.MutableRefObject<Array<string | null>>;
    activeIndex: number | null;
    onMatch?: (index: number) => void;
    onTypingChange?: (isTyping: boolean) => void;
    enabled?: boolean;
    findMatch?: null | ((list: Array<string | null>, typedString: string) => string | null | undefined);
    resetMs?: number;
    ignoreKeys?: Array<string>;
    selectedIndex?: number | null;
}

export { VirtualElement }

export { }
